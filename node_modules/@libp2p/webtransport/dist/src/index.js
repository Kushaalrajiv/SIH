import { noise } from '@chainsafe/libp2p-noise';
import { symbol } from '@libp2p/interface/transport';
import { logger } from '@libp2p/logger';
import {} from '@multiformats/multiaddr';
import { webtransportBiDiStreamToStream } from './stream.js';
import { inertDuplex } from './utils/inert-duplex.js';
import { isSubset } from './utils/is-subset.js';
import { parseMultiaddr } from './utils/parse-multiaddr.js';
const log = logger('libp2p:webtransport');
class WebTransportTransport {
    components;
    config;
    constructor(components, init = {}) {
        this.components = components;
        this.config = {
            maxInboundStreams: init.maxInboundStreams ?? 1000
        };
    }
    [Symbol.toStringTag] = '@libp2p/webtransport';
    [symbol] = true;
    async dial(ma, options) {
        options?.signal?.throwIfAborted();
        log('dialing %s', ma);
        const localPeer = this.components.peerId;
        if (localPeer === undefined) {
            throw new Error('Need a local peerid');
        }
        options = options ?? {};
        const { url, certhashes, remotePeer } = parseMultiaddr(ma);
        if (remotePeer == null) {
            throw new Error('Need a target peerid');
        }
        if (certhashes.length === 0) {
            throw new Error('Expected multiaddr to contain certhashes');
        }
        let abortListener;
        let maConn;
        let cleanUpWTSession = () => { };
        try {
            let closed = false;
            const wt = new WebTransport(`${url}/.well-known/libp2p-webtransport?type=noise`, {
                serverCertificateHashes: certhashes.map(certhash => ({
                    algorithm: 'sha-256',
                    value: certhash.digest
                }))
            });
            cleanUpWTSession = (closeInfo) => {
                try {
                    if (maConn != null) {
                        if (maConn.timeline.close != null) {
                            // already closed session
                            return;
                        }
                        // This is how we specify the connection is closed and shouldn't be used.
                        maConn.timeline.close = Date.now();
                    }
                    if (closed) {
                        // already closed session
                        return;
                    }
                    wt.close(closeInfo);
                }
                catch (err) {
                    log.error('error closing wt session', err);
                }
                finally {
                    closed = true;
                }
            };
            // this promise resolves/throws when the session is closed or failed to init
            wt.closed
                .then(async () => {
                await maConn?.close();
            })
                .catch((err) => {
                log.error('error on remote wt session close', err);
                maConn?.abort(err);
            })
                .finally(() => {
                // if we never got as far as creating the maConn, just clean up the session
                if (maConn == null) {
                    cleanUpWTSession();
                }
            });
            // if the dial is aborted before we are ready, close the WebTransport session
            abortListener = () => {
                if (abortListener != null) {
                    options.signal?.removeEventListener('abort', abortListener);
                }
                cleanUpWTSession();
            };
            options.signal?.addEventListener('abort', abortListener);
            await wt.ready;
            if (!await this.authenticateWebTransport(wt, localPeer, remotePeer, certhashes)) {
                throw new Error('Failed to authenticate webtransport');
            }
            maConn = {
                close: async (options) => {
                    log('Closing webtransport');
                    cleanUpWTSession();
                },
                abort: (err) => {
                    log('aborting webtransport due to passed err', err);
                    cleanUpWTSession({
                        closeCode: 0,
                        reason: err.message
                    });
                },
                remoteAddr: ma,
                timeline: {
                    open: Date.now()
                },
                // This connection is never used directly since webtransport supports native streams.
                ...inertDuplex()
            };
            options?.signal?.throwIfAborted();
            return await options.upgrader.upgradeOutbound(maConn, { skipEncryption: true, muxerFactory: this.webtransportMuxer(wt, cleanUpWTSession), skipProtection: true });
        }
        catch (err) {
            log.error('caught wt session err', err);
            cleanUpWTSession({
                closeCode: 0,
                reason: err.message
            });
            throw err;
        }
        finally {
            if (abortListener != null) {
                options.signal?.removeEventListener('abort', abortListener);
            }
        }
    }
    async authenticateWebTransport(wt, localPeer, remotePeer, certhashes) {
        const stream = await wt.createBidirectionalStream();
        const writer = stream.writable.getWriter();
        const reader = stream.readable.getReader();
        await writer.ready;
        const duplex = {
            source: (async function* () {
                while (true) {
                    const val = await reader.read();
                    if (val.value != null) {
                        yield val.value;
                    }
                    if (val.done) {
                        break;
                    }
                }
            })(),
            sink: async function (source) {
                for await (const chunk of source) {
                    await writer.write(chunk);
                }
            }
        };
        const n = noise()();
        const { remoteExtensions } = await n.secureOutbound(localPeer, duplex, remotePeer);
        // We're done with this authentication stream
        writer.close().catch((err) => {
            log.error(`Failed to close authentication stream writer: ${err.message}`);
        });
        reader.cancel().catch((err) => {
            log.error(`Failed to close authentication stream reader: ${err.message}`);
        });
        // Verify the certhashes we used when dialing are a subset of the certhashes relayed by the remote peer
        if (!isSubset(remoteExtensions?.webtransportCerthashes ?? [], certhashes.map(ch => ch.bytes))) {
            throw new Error("Our certhashes are not a subset of the remote's reported certhashes");
        }
        return true;
    }
    webtransportMuxer(wt, cleanUpWTSession) {
        let streamIDCounter = 0;
        const config = this.config;
        return {
            protocol: 'webtransport',
            createStreamMuxer: (init) => {
                // !TODO handle abort signal when WebTransport supports this.
                if (typeof init === 'function') {
                    // The api docs say that init may be a function
                    init = { onIncomingStream: init };
                }
                const activeStreams = [];
                (async function () {
                    //! TODO unclear how to add backpressure here?
                    const reader = wt.incomingBidirectionalStreams.getReader();
                    while (true) {
                        const { done, value: wtStream } = await reader.read();
                        if (done) {
                            break;
                        }
                        if (activeStreams.length >= config.maxInboundStreams) {
                            // We've reached our limit, close this stream.
                            wtStream.writable.close().catch((err) => {
                                log.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);
                            });
                            wtStream.readable.cancel().catch((err) => {
                                log.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);
                            });
                        }
                        else {
                            const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), 'inbound', activeStreams, init?.onStreamEnd);
                            activeStreams.push(stream);
                            init?.onIncomingStream?.(stream);
                        }
                    }
                })().catch(() => {
                    log.error('WebTransport failed to receive incoming stream');
                });
                const muxer = {
                    protocol: 'webtransport',
                    streams: activeStreams,
                    newStream: async (name) => {
                        const wtStream = await wt.createBidirectionalStream();
                        const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), init?.direction ?? 'outbound', activeStreams, init?.onStreamEnd);
                        activeStreams.push(stream);
                        return stream;
                    },
                    /**
                     * Close or abort all tracked streams and stop the muxer
                     */
                    close: async (options) => {
                        log('Closing webtransport muxer');
                        cleanUpWTSession();
                    },
                    abort: (err) => {
                        log('Aborting webtransport muxer with err:', err);
                        cleanUpWTSession({
                            closeCode: 0,
                            reason: err.message
                        });
                    },
                    // This stream muxer is webtransport native. Therefore it doesn't plug in with any other duplex.
                    ...inertDuplex()
                };
                return muxer;
            }
        };
    }
    createListener(options) {
        throw new Error('Webtransport servers are not supported in Node or the browser');
    }
    /**
     * Takes a list of `Multiaddr`s and returns only valid webtransport addresses.
     */
    filter(multiaddrs) {
        return multiaddrs.filter(ma => ma.protoNames().includes('webtransport'));
    }
}
export function webTransport(init = {}) {
    return (components) => new WebTransportTransport(components, init);
}
//# sourceMappingURL=index.js.map